---

layout: post
category: "Java"
title:  "疯狂java讲义学习——泛型"
tags: [疯狂java]

---

Java泛型可以保证如果程序在编译时没有发出警告，运行时就不会产生ClassCastException异常。

## 泛型入门
Java集合设计成能保存任何类型的对象，只要求具有很好的通用性，但同时带来以下两个问题：

* 可能引发异常；
* 强制类型转换，增加了编程的复杂度；

##### 使用泛型
从Java 5以后，Java引入了“参数化类型”的概念，允许程序在创建集合时指定集合元素的类型。Java的参数化类型被成为泛型。

##### Java 7泛型的“菱形”语法
在Java 7以前，如果使用待泛型的接口、类定义变量，那么调用构造器创建对象时构造器的后面也必需带泛型，显得有些多余`List<String> strList = new ArrayList<String>();`

从Java 7开始，Java允许在构造器后不需要带完整的泛型信息，只要给出一对尖括号(<>)即可，例如`List<String> strList = new ArrayList<>();`

把两个尖括号并排放在一起像一个菱形，故此语法被称为“菱形”语法。

## 深入泛型
所谓泛型，就是允许在定义类、接口、方法时使用类型形参，这个类型形参将在声明变量、创建对象、调用方法时动态地指定。

##### 定义泛型接口、类
包含泛型声明的类型可以在定义变量、创建对象时传入一个类型实参，从而可以动态地生成无数多个逻辑上的子类，但这种子类在物理上并不存在。

当创建泛型声明的自定义类，为该类定义构造器时，构造器名还是原来的类名，不要增加泛型声明。

##### 从泛型类派生子类
定义类、接口、方法时可以声明类型形参，使用类、接口、方法时应该为类型形参传入实际的类型。例如从泛型类派生子类时，正确和错误的下面代码如下：

* 错。`public class SubClassName extends SuperClassName<T>{}`;
* 对。`public class SubClassName extends SuperClassName<String>{}`;
* 对。`public class SubClassName extends SuperClassName{}`;

##### 并不存在泛型类
不管泛型的实际类型参数是什么，它们在运行时总有同样的类（class）。不管泛型的类型形参传入哪一种类型实参，对于Java来说，它们依然被当成同一个类处理，在内存中也占用一块内存空间，因此在静态方法、静态初始化块或者静态变量的声明和初始化中不允许使用类型形参。instanceof运算符后也不能使用泛型类。

## 类型通配符
如果Foo是Bar的子类型（子类或者子接口），而G是具有泛型声明的类或接口，G<Foo>并不是G<Bar>的子类型！这一点非常值得主义。

Java泛型的设计原则是，只要代码在编译时没有出现警告，就不会遇到运行时ClassCastException异常。

##### 使用类型通配符
类型通配符是一个问号(?)，将一个问号作为类型实参传给List集合，写作：List<?>。这个问号(?)被称为通配符，它的元素类型可以匹配任何类型。但这种带通配符的List仅表示它是各种泛型List的父类，并不能把元素加入到其中。例如以下代码会引起编译错误：
<code>
  <pre>
    List<?> c = new ArrayList<String>();
    c.add(new Object());
  </pre>
</code>

##### 设定类型通配符的上限
被限制的泛型通配符表示如下：`List<? extends SuperClassName>`,把SuperClassName称为这个通配符的上限（upper bound）；

##### 设定类型形参的上限
Java泛型不仅允许在使用通配符形参时设定上限，而且可以在定义类型形参时设定上限，用于表示传给该类型形参的实际类型要么是该上限类型，要么是该上限类型的子类。程序要为类型形参设定多个上限（至多有一个父类上限，可以有多个接口上限），表明该类型形参必需是其父类的子类（是父类本身也可以），并且实现多个上限接口。如果需要为类型形参指定类上限，类上限必需位于第一位。

## 泛型方法
##### 定义泛型方法
Java 5提供泛型方法(Generic Method)。所谓泛型方法，就是在声明方法时定义一个或多个类型形参。泛型方法的语法格式如下：
<code>
 <pre>
   修饰符 <T,S> 返回值类型 方法名(形参泪飙)
   ｛
      //方法体.....
    ｝ 
 </pre>
</code>

泛型方法中，类型形参以尖括号括起来，多个类型形参之间以逗号(,)隔开，所有类型形参声明放在修饰符和方法返回值类型之间。方法声明中定义的形参只能在该方法使用。

##### 泛型方法与类型通配符的区别
大多时候都可以使用泛型方法来代替类型通配符。通配符是被设计用来支持灵活的子类化的。

泛型方法允许类型形参被用来表示方法的一个或多个参数之间的类型以来关系，或者方法返回值与参数之间的类型以来关系。如果没有这样的类型以来关系，就不应该使用泛型方法。

类型通配符既可以在方法签名中定义形参的类型，也可以用于定义变量的类型；但泛型方法中的类型形参必须在对应方法中显式声明。

##### Java 7的“菱形”语法与泛型构造器
Java允许在构造器签名中声明类型形参，这就产生了所谓的泛型构造器。

Java 7新增的“菱形”语法，它允许调用构造器时在构造器后使用一对尖括号来代表泛型信息。但如果程序显式制订了泛型构造器中声明的类型形参的实际类型，则不可以使用“菱形”语法。

##### 设定通配符下限
Java允许设定通配符的下限：`<? super Type>`，这个通配符表示它必须是Type本身，或是Type的父类。

##### 泛型方法与方法重载
因为泛型允许设定通配符的上限，也允许设定通配符的下限，从而允许在一个类里可能包含如下两个方法定义：
<code>
 <pre>
   public static <T> void copy(Collection<T> dest,Collection<? extends T> src){...}
   public static <T> void copy(Collection<? super T> dest,Collection<T> src){...}
 </pre>
</code>

以上这两个方法在调用时将会引起编译错误，虽然其参数列表存在一定的区别，但是这个区别并不明确。

##### Java 8改进的类型推断
Java 8改进了泛型方法的类型推断能力，类型推断主要包括两个方面：

* 可通过调用方法的上下文来推断类型参数的目标类型；
* 可在方法调用链中，将推断得到的类型参数传递到最后一个方法；

## 擦出和转换
在严格的泛型代码里，带泛型声明的类总应该带着类型参数。

当把一个具有泛型信息的对象赋给另一个没有泛型系想你的变量时，所有在尖括号之间的类型信息都将被扔掉[**擦出**];

## 泛型与数组
数组元素的类型不能包含类型变量或类型形参，除非是无上限的类型通配符。但可以声明元素类型包含类型变量或类型形参的数组。即，只能声明List<String>[]形式的数组，但不能创建ArrayList<String>[10]这样的数组对象。

## 注：“擦出和转换”、“泛型和数组”需进一步深入了解




