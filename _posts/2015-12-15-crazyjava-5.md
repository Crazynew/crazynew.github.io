---

layout: post
category: "Java"
title:  "疯狂java讲义学习——面向对象（上）"
tags: [疯狂java]

---

## 类和对象

Java语言定义类的基本语法如下:
<code>
<pre>
   package com.crazynew.javacrazy.... //0到1个package语句
   
   import java.util.... //0到n个import语句
   
   [修饰符] class SubClass [exdens SuperClass]
   {
       //零个到多个初始化块 【静态初始化块、非静态初始化块】
       //零个到多个构造器定义...
       //零个到多个成员变量...
       //零个到多个方法...
   }  
</pre>
</code>

_Tips:_

1. 修饰符可以是public（公有类）、final（最终类）、abstract（抽象类）
2. 类定义最常见成员：构造器、成员变量、方法。其中构造器是一个类创建对象的根本途径；成员变量表示类及其实例的状态属性数据；方法表示类及其实例的行为。

##### 成员变量
定义成员变量的语法格式：
<code>
<pre>
  [修饰符] 类型 成员变量 [= 默认值]
</pre>
</code>

_Tips:_

1. 修饰符：可以省略；也可以public、protected、private、static、final；public、protected、private三个中最多只能出现其一，与static、final组合起来使用；
2. 类型：基本类型和引用类型；
3. 成员变量名：标示符，第一个单词首字母小写，后面每个单词首字母大写，其余全部字母小写；

##### 方法
定义方法的语法格式：
<code>
<pre>
  [修饰符] 方法返回值类型 方法名 （形参列表）
  {
      //由零条到多条可执行性语句组成的方法体
  }
</pre>
</code>

_Tips:_

1. 修饰符：可以省略；也可以public、protected、private、static、final、abstract；public、protected、private三个中最多只能出现其一，abstract和final只能出现其一，与static组合起来使用；
2. 方法返回值类型：基本类型和引用类型；若无返回类型，则必须使用void声明；
3. 形参列表：谁调用方法，谁负责为形参赋值；

**注：static是一个特殊的关键字，可用于修饰方法、成员变量等成员，static修饰成员表明它属于类本身，不属于单个实例，即可称为类变量、类方法。（static修饰）静态成员不能直接访问非静态成员。另外，java编程时建议不要使用对象去调用static修饰的成员变量、方法，而是应该使用类去调用static修饰IDE成员变量、方法！**

##### 构造器
定义构造器的语法格式：
<code>
<pre>
  [修饰符]  构造器名 （形参列表）
  {
      //由零条到多条可执行性语句组成的构造器执行体
  }
</pre>
</code>

_Tips:_

1. 修饰符：可以省略；也可以public、protected、private之一；
2. 构造器名：必须与类名相同；
3. 构造器既不能定义返回值类型，也不能使用void声明构造器没有返回值；否则，编译时虽然不会出错，但Java会把这个所谓的构造器当成方法来处理。

##### this关键字
* this关键字总是指向调用该方法的对象；
* 当this出现在某个方法体中，它所代表的对象时不确定的，但它的类型是确定的：它所代表的只能是当前类的实例；
* java允许对象的一个成员直接调用另一个成员，可以省略this前缀；
* static修饰的方法中不能使用this引用；
* this在构造器中代表该构造器正在初始化的对象；
* 使用this作为方法的返回值可以让代码更加简洁，但可能造成实际意义的模糊；

## 方法详解

##### 方法的所属性
* 方法不能独立定义，只能在类体里定义；
* 逻辑上看，方法要么属于类本身，要么属于该类的一个对象；
* 执行方法必须使用类或对象作为调用者；

##### 方法的参数传递机制
Java里方法的参数传递方式只有一种：值传递（就是将实际参数值的副本（复制品）传入方法内，而参数本身不会受到任何影响）

**注：Java对于引用类型的参数传递，一样采用的是值传递方法，可以从底层内存分配机制详解得到其原理。**
##### 形参个数可变的方法
从JDK1.5之后，Java允许定义形参个数可变的参数，从而允许为方法指定数量不确定的形参（在最后一个形参的类型后增加三点...，则表明该形参可以接受多个参数值，多个参数值被当成数组传入）

**注：数组形式的形参可以处于形参形参列表的任意位置，但个数可变的形参只能处于形参列表的最后，即一个方法中最多只能有一个个数可变的形参。**

##### 递归方法

最重要的规定：递归一定要向已知方向递归；

##### 方法重载

基本要求“两同一不同”：同一个类中方法名相同，参数列表不同

**注：大部分时候不推荐重载形参个数可变的方法，因为无意义，而且容易降低程序的可读性**

## 成员变量和局部变量
![变量分类图](http://i4.tietuku.com/5e49e81606d85864.png)

_Tips:_

* 局部变量除了形参之外，都必须显式初始化，否则不可以访问它们；
* 如果方法里的局部变量和成员变量同名，局部变量会覆盖成员变量，如果需要在这个方法里引用被覆盖的成员变量，则可以使用this（对于实力变量）或类名（对于类变量）作为调用者来限定成员变量；
* 变量的初始化及其在内存中的运行机制（栈内存、堆内存如何分配？）
* 局部变量的作用范围越小，它在内存里停留的时间就越短，程序运行性能越好；

## 隐藏和封装
对一个类或对象实现良好的封装，实现以下目的：

* 隐藏实现细节；
* 添加控制逻辑
* 进行数据检查
* 增加可维护性

**总之，该藏则藏，该露则露**

使用访问控制符可实现良好的封装.访问控制级别表如下：
<table>
  <tr>
    <th></th>
    <th>private</th>
    <th>default</th>
    <th>protected</th>
    <th>public</th>
  </tr>
  <tr>
    <th>同一个类中</th>
    <td>ok</td>
    <td>ok</td>
    <td>ok</td>
    <td>ok</td>
  </tr>
  <tr>
    <th>同一个包中</th>
    <td></td>
    <td>ok</td>
    <td>ok</td>
    <td>ok</td>
  </tr>
  <tr>
    <th>子类中</th>
    <td></td>
    <td></td>
    <td>ok</td>
    <td>ok</td>
  </tr>
  <tr>
    <th>全局范围内</th>
    <td></td>
    <td></td>
    <td></td>
    <td>ok</td>
  </tr>
</table> 

_Tips:1. 对于外部类而言，可以使用访问控制修饰符，但外部类只能访问控制修饰符只能是public和默认之一，不能使用protected和private修饰； 2. 如果一个java类的每个实例变量都被使用private修饰，并未每个实例变量提供了public修饰的setter和getter方法，那么这个类就是一个符合JavaBean规范的类_

访问控制符使用的几条基本原则：

* 雷利的绝对部分成员变量都应该使用private修饰，只有一些static修饰的，类似全局变量的成员变量，才可能考虑使用public修饰，另外，类里的工具方法也应该使用private修饰；
* 父类包含的大部分方法可能仅系统被其子类重写，则应该使用protected修饰；
* 大部分外部类都是用public修饰

##### package和import说明：

package：提供类的多层命名空间，用于解决类的命名冲突、类文件管理等问题；**注：位于包中的类，在文件系统中也必须有与包名层次相同的目录结构。**

一句话归纳import和import static的作用：使用import可以省略写包名；而使用import static则可以连类名都省略；

## 深入构造器
构造器作为一个特殊的方法，用于创建实例时执行初始化，Java类必须包含一个或一个以上的构造器；

* 构造器是创建Java对象的途径，但是类的对象并不是完全由构造器负责创建的。实际上，在程序猿调用构造器时，系统会先为该对象分配内存空间，并未这个对象执行默认初始化，即执行构造器的执行体之前，系统已经创建了一个对象，只是这个对象还不能被外部程序访问，只能在该构造器中通过this来引用。
* 构造器重载。**注：当构造器B完全包含了构造器A，则在B中可以首先通过this调用A，再执行其他的语句。使用this调用另一个重载的构造器只能在构造器中使用，而且必须作为构造器执行体的第一条语句。** 

## 类的继承
Java的继承具有单继承的特点，每个子类只有一个直接父类。

继承的特点：

* 父类是大类，子类是小类
* Java的子类不能获得父类的构造器
* java.lang.Object类是所有类的父类，所以所有的对象都可调用java.lang.Object类所定义的实例方法；

**方法重写（覆盖）：子类包含与父类同名方法的现象。**

* 覆盖方法与被覆盖方法要么都是类方法，要么都是实例方法；
* 如果需要在子类中调用弗雷中被覆盖的方法，则可以使用super（被覆盖的是实例方法）或者父类类名（被覆盖的是类方法）作为调用者来调用父类中被覆盖的方法。
* super用于限定该对象调用它从父类继承得到的实例变量或方法，super也不能出现在static修饰的方法中。
* 若被覆盖的是类变量，在子类的方法中则可以通过父类名作为调用者来访问被覆盖的类变量；
*使用super调用父类的构造器必须出现在子类构造器执行体的第一行，所以this调用和super调用不会同时出现。 
* 子类构造器总会调用父类构造器一次。创建任何对象总是从该类所在继承树最顶层类的构造器开始执行，然后依次向下执行，最后才执行本类的构造器；

## 多态

Java引用变量有两个类型：一个是编译时类型，一个是运行时类型。编译时类型由声明该变量时使用的类型决定，运行时类型由实际赋给该变量的对象决定。

**多态：相同类型的变量、调用同一个方法时呈现出多种不同的行为特征**

_Tips:_

* 对象的实例变量不具备多态性；
* 通过引用变量来访问其包含的实例变量时，系统总是试图访问它编译时类型所定义的成员变量，而不是它运行时类型所定义的成员变量；
* 引用变量只能调用它编译时类型的方法，而不能调用它运行时类型的方法。

**强制类型转换(type)variable：**

* 基本类型之间的转换只能在数值之间进行；
* 引用类型之间的转换只能在具有继承关系的两个类型之间进行；
* 进行类型转换之前应通过instanceof运算符来判断是否可以成功转换，以提高程序的健壮性；

**instanceof运算符**

* instanceof运算符前面操作数的编译时类型要么与后面的类相同，要么与后面的类具有父子继承关系，否则会引起编译错误；
* instanceof和（type）作为两个相关的运算符，总是结合使用。

## 继承与组合

继承可以实现类复用，但是却**破坏封装**

设计父类遵循的规则：

* 尽量隐藏父类的内部数据；
* 不要让子类可以随意访问、修改父类的方法；
* 尽量不要在父类构造器中调用将要被子类重写的方法；

继承——“is a”；组合——“has a”；

## 初始化块
初始化块作为java类里出现的第四种成员，一个类里可以有多个初始化块，相同类型的初始化块之间有顺序：前面定义的初始化块先执行，后面定义的初始化块后执行；
<code>
 <pre>
   [修饰符] {
      //初始化块的可执行性代码....
   }
 </pre>
</code>
_Tips:_

* 初始化块的修饰符只能是static；
* 初始化块只在创建Java对象时隐式执行，而且在执行构造器之前执行
* 普通初始化块、声明实例变量指定的默认值都可认为是对象的初始化代码，它们的执行顺序与源程序的排列顺序相同；
* 初始化块对同一个类的所有对象所进行的初始化处理完全相同；
* 如果两个构造器有相同的初始化代码，且这些初始化代码无须接收参数，就可以把它们放在初始化块中定义；
* 使用static修饰的初始化块被称为静态初始化块；
* 普通初始化块负责对对象执行初始化，类初始化块则负责对类进行初始化；所以静态初始化块总是比普通初始化块先执行；
* Java系统加载并初始化某个类时，总是保证该类的所有父类（包括直接父类和间接父类）全部加载并初始化；