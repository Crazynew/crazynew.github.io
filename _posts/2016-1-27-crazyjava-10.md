---

layout: post
category: "Java"
title:  "疯狂java讲义学习——异常处理"
tags: [疯狂java]

---

## 异常概述

异常机制可以使程序中的异常处理代码和正常业务代码分离，保证程序代码更加优雅，并可以提高程序的健壮性。

Java将异常分为两种：Checked异常和Runtime异常。Java认为Checked异常都是可以在编译阶段被处理的异常，所以它强制处理所有的Checked异常，而Runtime异常则无须处理。

Java的异常机制主要依赖于try、catch、finally、throw、throws五个关键字。

## 异常处理机制
当程序运行出现意外情形时，系统会自动生成一个Exception对象来通知程序，从而实现将“业务功能实现代码”和“错误处理代码”分离，提供更好的可读性。

##### 使用try...catch捕获异常
<code>
 <pre>
   try
   {
       //业务实现代码
   }
   catch(Exception e)
   {
       //异常处理代码
   }
 </pre>
</code>
只要执行该代码块时出现了异常，系统总会自动生成一个异常对象。

##### 异常类的继承体系
![](http://i8.tietuku.com/58cebd40f738118b.png)

Java把所有非正常情况分为两种：异常（Exception）和错误（Error）,都继承至Throwable父类。

Error错误，一般指与虚拟机相关的问题，如系统崩溃、虚拟机错误、动态链接失败等，这种错误无法恢复或不可能捕获，将导致应用程序终端。

异常捕获时，一定要记住先捕获小异常，再捕获大异常。

##### Java 7提供的多异常捕获
从Java 7开始，一个catch块可以捕获多种类型的异常。使用一个catch块捕获多种类型的异常时需要注意以下两点：

* 多种异常类型之间用竖线(|)隔开；
* 异常变量有隐式的final修饰，因此程序不能对异常变量重新赋值；【捕获一种类型的异常时，异常变量没有final修饰】

##### 访问异常信息
所有异常对象都包含了如下几个常用方法：

* getMessage():返回该异常的详细描述字符串；
* printStackTrace():将该异常的跟踪栈信息输出到标准错误输出；
* printStackTrace(PrintStream s):将该异常的跟踪栈信息输出到指定输出流；
* getStackTrace():返回该异常的跟踪栈信息。

##### 使用finally回收资源
为了保证一定能回收try块中打开的物理资源，异常处理机制提供了finally块，finally块总会被执行。

异常处理语法结构中只有try块是必需的，catch块和finally块都是可选的，二者至少出现其一。但不能只有try块，既没有catch块，也没有finally块。

除非在try块、catch块中调用了退出虚拟机的方法`System.exit(1)`，否则不管在try块、catch块中执行怎样的代码，出现怎样的情况，异常处理的finally块总会被执行。

在通常情况下，不要在finnaly块中使用如return或throw等导致方法终止的语句，一旦在finally块中使用了return或throw语句，将会导致try块、catch块中的return、throw语句失效。

##### 异常处理的嵌套
在try、catch块或finally块中包含完整的异常处理流程的情形被称为异常处理的嵌套。通常没有必要使用超过两层的嵌套异常处理，层次太深，导致程序可读性降低。

##### Java 7的自动关闭资源的try语句
Java 7增强了try语句的功能——它允许在try关键字后紧跟一对圆括号，圆括号可以声明、初始化一个或多个资源，此处的资源指的是那些必须在程序结束时显式关闭的资源（比如数据库连接、网络连接等），try语句在该语句结束时自动关闭这些资源。

为了保证try语句可以正常关闭资源，这些资源实现类必须实现AutoCloseable或Closeable接口，实现这两个接口就必需实现close()方法。

<code>
 <pre>
   public class AutoCloseTest
   {
     public static void main(String[] args)
     {
        try(
          BufferReader br = new BufferReader(new FileReader("AutoCloseTest.java"));
          PrintStream ps = new PrintStream(new FileOutputStream("a.txt"))
        )
        {
          System.out.println(br.readLine());
          ps.println("hello");
        }
     }
   }
 </pre>
</code>

自动关闭资源的try语句相当于包含了隐式的finally块(这个finally块用于关闭资源)，因此这个try语句可以既没有catch块，也没有finally块。

## Checked异常和Runtime异常体系
所有的RuntimeException类及其子类被称为Runtime异常；其余都是Checked异常。

只有Java语言提供了Checked异常。Checked异常体现了Java的设计哲学——没有完善错误处理的代码根本就不会被执行。

Checked异常的处理方式有如下两种：

* 当前方法明确指导如何处理该异常，程序应该使用try...catch块来捕获该异常，然后在对应的catch块修复该异常；
* 当前方法不知道如何处理这种异常，应该在定义该方法时声明抛出该异常；

Checked异常降低了程序开发的生产率和代码的执行效率（因为大部分方法总是不能明确指导如何处理异常，因此只能声明抛出该异常）。

Runtime异常更加灵活，无须显式声明抛出，如果程序需要捕获Runtime异常，也可以使用try...catch块来实现。

##### 使用throws声明抛出异常
使用throws声明抛出医生的思路是：当前方法中不知道如何处理这种类型的异常，该异常应该由上一级调用者处理。main方法的上一级调用者是JVM，JVM对异常的处理方法是，打印异常的跟踪栈系想你，并中止程序运行。

throws声明抛出只能在方法签名中使用，throws可以声明抛出多个异常类，多个异常类之间用逗号隔开。语法格式`throws ExceptionClass1,ExceptionClass2...`。一旦使用了throws语句声明抛出异常，程序就无须使用try...catch块来捕获异常了。

如果某段代码中调用了一个带throws声明的方法，该方法声明跑出了Checked异常，则表明该方法希望它的调用者来处理该异常。即，调用该方法时要么放在try块中显式捕获该异常，要么放在另一个带throws声明抛出的方法中。

使用throws声明抛出异常时有一个限制，就是方法重写时“两小”中的一条原则：子类方法声明抛出的异常类型应该是父类方法声明抛出的异常类型的子类或相同，子类方法声明抛出的异常不允许比父类方法声明抛出的异常多。

使用Checked异常的两大不便之处：

* 对于程序汇总的Checked异常，Java要求必须显式捕获并处理该异常，或者显式声明抛出该异常，增加了编程复杂度；
* 如果在方法中显式声明抛出Checked异常，将会导致方法签名与异常耦合，如果该方法是重写父类的方法，则该方法抛出的异常还会收到被重写方法所抛出异常的限制；

在大部分时候推荐使用Runtime异常，而不使用Checked异常。

## 使用throw抛出异常
程序自行抛出异常使用throw语句完成。
##### 抛出异常
由于与业务需求不符而产生的异常，必须由程序员来决定抛出，系统无法抛出这种异常。

throw语句抛出的不是异常类，而是一个异常实例，而且每次只能抛出一个异常实例。`throw ExceptionInstance`。

无论是系统自动抛出的异常，还是程序猿手动抛出的异常，java运行时环境对异常的处理没有任何差别。

自行抛出Runtime异常比自行抛出Checked异常的灵活性更好。同样，抛出Checked异常则可以让编译器提醒程序猿必须处理该异常。

##### 自定义异常类
用户自定义异常都应该继承Exception基类，如果希望自定义Runtime异常，则应该继承RuntimeException基类。定义异常类时通常需要提供两个构造器：一个是无参数的构造器；另一个是带一个字符串参数的构造器，这个字符串将作为该异常对象的描述信息（也就是异常对象的getMessage()方法的返回值）。

##### catch和throw同时使用
为了实现通过多个方法协作处理同一个异常的情形，可以在catch块中结合throw语句来完成。

##### Java 7增强的throw语句
从Java 7开始，Java编译器会执行更加细致的检查，Java编译器会检查throw语句抛出异常的实际类型。

##### 异常链
把底层的原始异常直接传给用户是一种不符责任的表现。通常的做法是：程序先捕获原始异常，然后抛出一个新的业务异常，新的业务异常中包含了对用户的提示信息，这种处理方式被称为“异常转译”。

## Java的异常跟踪栈
异常对象的printStackTrace()方法用于打印异常的跟踪栈信息。虽然printStackTrace()方法可以很方便地用于追踪异常的发生情况，可以用它来调试程序，但在最后发布的程序中，应该避免使用它；而应该对捕获的异常进行适当地处理，而不是简单地将异常的跟踪栈系想你打印出来。

## 异常处理规则
成功的异常处理应该实现的4个目标：

* 是程序代码混乱最小化；
* 捕获并保留诊断系想你；
* 通知合适的人员；
* 采用何时的方式结束异常活动；

##### 不要过度使用异常
异常只应该用于处理非正常的情况，不要使用异常处理来代替正常的流程控制。
##### 不要使用过于庞大的try块
正确的做法：把大块的try块分割成多个可能出现异常的程序段落，并把它们放在单独的try块中，从而分别捕获并处理异常。
##### 避免使用Catch All语句
所谓Catch All语句指的是一种异常捕获模块，它可以处理程序发生的所有可能异常。Catch All语句不过是一种通过避免错误处理而加快编程进度的机制，应尽量避免在实际应用中使用这种语句。
##### 不要忽略捕获到的异常
catch块整个为空，或者仅仅打印出错信息都是不妥的。
